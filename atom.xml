<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://elaina.mip001.top</id>
    <title>Elaina&apos;s blog</title>
    <updated>2024-06-07T11:37:13.281Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://elaina.mip001.top"/>
    <link rel="self" href="https://elaina.mip001.top/atom.xml"/>
    <subtitle>逸一时，误一世</subtitle>
    <logo>https://elaina.mip001.top/images/avatar.png</logo>
    <icon>https://elaina.mip001.top/favicon.ico</icon>
    <rights>All rights reserved 2024, Elaina&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[日志]]></title>
        <id>https://elaina.mip001.top/post/ri-zhi/</id>
        <link href="https://elaina.mip001.top/post/ri-zhi/">
        </link>
        <updated>2024-05-30T05:07:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="2024528">2024.5.28</h3>
<p>学习了一下数论：唯一分解定理，欧拉函数，欧拉定理。</p>
<p>顺便过掉了一道 Tarjan+DP 的题，之前有过三个问题：</p>
<ol>
<li>BFS 用递归写，爆栈 MLE 了。</li>
<li>没拓扑排序，进死循环 TLE 了。</li>
<li>Tarjan 写重复了，执行了 n 次，WA 了。</li>
</ol>
<h3 id="2024529">2024.5.29</h3>
<h4 id="p4139-p2158">P4139 P2158</h4>
<p>还是在学习数论，学习了扩展欧拉定理。过掉了第一道紫题。</p>
<p>顺带复习了一下 GCD 以及 exGCD ，过了</p>
<h3 id="2024530">2024.5.30</h3>
<h4 id="p3868-p4774-p1495">P3868 P4774 P1495</h4>
<p>上午复习了一下  CRT，过掉了板子，顺便发现了自己之前写的快读的问题。思考了一下 DAG 跑背包问题。下午考虑一下怎么用滚动数组优化。</p>
<p>下午写了一道图上的 DP ,还是比较明显的，缩点一下就可以了。学习了 exCRT，过掉了一道紫。</p>
<h3 id="2024531">2024.5.31</h3>
<p>上午：正在考虑怎么把有边权图转化为带点权的图。或许可以把每个有向边的两端点都加上这条边权，最后的结果除以二就可以了。后来发现根本不需要，强连通分量里的边权加起来就是这个分量的点权，其他点点权为 0 就可以了，DP 时把点权和边权一起算就可以了。</p>
<p>后来发现交上去 WA 了 7 个点。检查了好久，还参考了一下别人的，才发现有一个细节的地方写错了，少写了 <code>vis[y]=0</code> 。码力还是太弱了啊，做一道题我调试时间就要花大半，<s>多写点大模拟</s>。</p>
<h3 id="202462">2024.6.2</h3>
<p>上午：参加了洛谷基础赛，T1 很快过了，T2 最开始就想到奇数不行偶数行。结果交上去的时候少打了一个括号，以为自己的结论是错的，得出了一个很奇妙的结论：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>+</mo><mo>(</mo><mo>(</mo><mi>n</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>4</mn><mo>)</mo><mo>×</mo><mo>(</mo><mi>n</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>)</mo><mo>×</mo><mo>(</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>)</mo><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n\bmod 2+((n\bmod 4)\times (n\bmod 2)\times ((n-1)\bmod 2))=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，就满足，（后来发现这是一个结论）。T3 思考了许久，感觉要用逆元来求组合数。但是判重的时候发现不会了。最后 200pts。以后还是要注意细节啊。</p>
<p>下午百度之星，没提前熟悉环境，交 T1 的时候没注意看提交，CE 了 2 次，吃了两个罚时。由于是 ACM 赛制，看到 T2 T4 过的人比较多，于是着手这两题，T2 推了 1 个小时，最后一步死活优化不到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>  只好放弃。T4 感觉是区间 DP + 快速求组合数。但是搞忘快速幂怎么写了。最后只  A 了一道题。</p>
<h3 id="202463~202464">2024.6.3~2024.6.4</h3>
<p>三诊。</p>
<p>不过间隙还是能抽一段时间来机房。</p>
<p>Tarjan 暂时告一段落。接下来一段时间复习一下线段树，多练习一下 DP .</p>
<p>今天写了一道线段树，思想上没什么问题，但是实现的时候总与思考时有出入。 A 一道题常常大多数时间都在调试。顺便吃了一下用位运算的亏，位运算常有各种玄学 Bug ，开了 O2 效率差距并不大，以后还是别用了。</p>
<h3 id="202465">2024.6.5</h3>
<p>好吧计划有变，发现自己的 Tarjan 还漏了一块点双连通分量，今天把它解决了。这个学期到正睿之前先把提高组大纲先过一遍，到正睿再进行深度的学习。</p>
<p>看了一下洛谷网校的课，顺着就把点双连通分量解决了。</p>
<p>写了一道线段树维护区间方差和平均数的题 P1471 思考后发现方差展开后就相当于维护区间平方和以及区间平均数的线段树，没调多久就 A 了(指将近一个小时)。</p>
<p>考虑一下怎么用线段树维护区间最大子段和。顺便温习了一下树状数组。</p>
<h3 id="202466">2024.6.6</h3>
<p>上午模拟赛，荣获了正数第二名的好成绩 (</p>
<p>8:10~8:30</p>
<p>上来先浏览四道题</p>
<p>T1 发现要用 exGCD ，不太会。</p>
<p>T2 感觉之前见过，但是不太好写的样子。感觉是区间 DP 一类的东西。</p>
<p>T3 开始被吓到了，以为用实时更新的并查集来做。</p>
<p>T4 也看起来不好惹的样子，一时也没什么思路，主要是树论学的也不多。</p>
<p>8:30~9:00</p>
<p>T1 先把 60pts 的暴力写了，用自己不太熟的 exGCD 搞了一会也没做出来。</p>
<p>估分: 60+0+0+0</p>
<p>9:00~9:40</p>
<p>T1 没思路转去搞 T3 ，重新理解了一下，发现就是一个有向图上找最小环的问题，用普通并查集判断一下即可。大概 40min 过掉了小样例。</p>
<p>估分: 60+0+100+0</p>
<p>9.40~11:50</p>
<p>T2 感觉有点难做，看了一下数据点，发现有几个点是只需要输出不能走到的城市的数量。然后就考虑用记忆化来优化 DFS 来判断从最低端起能否走到上面。于是按理来说应该有 30 pts 了。然后考虑正常性质，发现了一个特性：在最顶端建造蓄水池，那么能灌溉到的最下方的村庄必然是一段连续的。于是用记忆化搜索处理出第一层每个点建造蓄水池能够灌溉到的区间的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l,r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 然后贪心求出最少需要的蓄水池。写完后发现样例居然过了，但是没有大样例，自己手搓的也感觉没问题。于是就觉得自己过了。</p>
<p>估分: 60+100+100+0</p>
<p>11:50~12:05</p>
<p>最后写 T4 的暴力发现最开始就思考错了，于是只好放弃。</p>
<p>提交的时候居然把 T3 的交错了。</p>
<p>实际得分: 60+20+100+0;</p>
<p>T2 不知为什么挂了，题还没补，补完再看。</p>
<p>2024.6.7</p>
<p>今天补了一下昨天模拟赛的几道题。</p>
<p>T1学了 exGCD 很快过了。T2 发现是自己少考虑了一种情况，不是只能向下走，改了一下就过了，不过差点 TLE 。可以学习一下手写栈来优化 DFS 。T4发现并没有想象中那么困难，就是一个 DP 。发现了一种新的思路：直接看一道题，一时半会儿没想出来可以从暴力和部分分入手，往往特殊性质就是对正解的引导。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-J/S 2023 游记]]></title>
        <id>https://elaina.mip001.top/post/csp-js-2023-you-ji/</id>
        <link href="https://elaina.mip001.top/post/csp-js-2023-you-ji/">
        </link>
        <updated>2023-12-11T03:19:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="day-1">Day -1</h3>
<p>3 点过就从学校走了，被发配到绵阳力（悲。</p>
<p>坐车到一半，接到教练的电话，发现准考证和学籍证明忘在了学校。<s>怎么这第一轮和第二轮都和这学籍证明有点关系</s></p>
<p>下午到酒店，和其他人一起吃了个饭，打了会板子，然后睡觉了。</p>
<h3 id="day-0">Day 0</h3>
<p>早饭吃的少，只吃了三两放了特别多花椒粉的米粉，麻了好一阵。</p>
<p>早上到校门口集合，随后进了考场。</p>
<p>漫长的等待开考时间。</p>
<h3 id="上午">上午</h3>
<p>8:30 了，开考了。</p>
<p>上场抱着及其自信的心态直接开了四道题，发现配置跟去年差不到哪里去（指 T3 都是大模拟</p>
<p>看到 T1 ，思考了两分钟，发现不就是个简单的数学吗，每次把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的值除以三，每一次循环 判断一下 n%3 是不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就可以了。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">10min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span> 成功过掉大样例和手搓的极端数据。</p>
<p>然后开始写 T2 最开始看到求最小费用以为是 DP ，但转念一想 J 组 T2 不至于考 DP ，然后 10min 想出贪心，30min写完，过了第一个样例，但是样例2没过，检查了好久没查出来，以为自己思路假了，又去想其他做法，半天没想出来。这时大概已经过了 2h 。</p>
<p>T3 大模拟压根不想碰，看到送了两个点，输出 0 走人。</p>
<p>这时候看到 T4 ，开始想先做特殊性质，搓了个堆优化的最短路，没过样例，想调但是只有30多min了，于是放弃了转去搞T2。</p>
<p>当时心态已经差不多炸了，最后10min想放弃，检查 freopen 和文件名，但是我不甘心，终于发现是自己一个递推式求错了，光速修改，距离结束还有几秒钟的时候过了样例，赶忙删掉了 freopen 的注释，保存了，但是不知道有没有保存成功。搞得一整天都好慌。好在最后还是保存成功了。（差点被吓死。。。</p>
<p>估分 100+100+10+?。</p>
<p>洛谷 100+95(?)+10+10。</p>
<h3 id="下午">下午</h3>
<p>2:30开考，等了一阵。</p>
<p>我们考场有位大哥电脑莫名其妙关了两次机。</p>
<p>开题了，速度浏览4道题，上午 T2 的惊险经历已经让我意识到了骄兵必败，于是下午特别谨慎。</p>
<p>T1 感觉好奇怪，但是部分分还是给的足足的，打了 60 pts 跑路，其实主要是想了两个小时都没数出来第二个样例的10个是怎么输出来的。</p>
<p>T2 一眼过去dp，想了一种 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的奇怪做法，但是好像思路假了，于是打了 25pts 的暴力跑路。</p>
<p>T3 大模拟，根本不想做。</p>
<p>T4 不会，打了暴力但调不出来。</p>
<p>结束了，就这么简单。</p>
<p>估分 60+25+0+0 。</p>
<p>没逝，我才初中。</p>
<p>出考场都觉得今年题好奇怪</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单 dp(1)]]></title>
        <id>https://elaina.mip001.top/post/jian-dan-dp1/</id>
        <link href="https://elaina.mip001.top/post/jian-dan-dp1/">
        </link>
        <updated>2023-10-17T06:09:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一节动态规划的定义">第一节:动态规划的定义</h2>
<h3 id="10-动态规划的引出">1.0: 动态规划的引出</h3>
<p>相信大家都学过搜索吧，但是大家在使用搜索解某些题的时候，有没有发现一个问题：搜索的效率太低了。</p>
<p>这时候，我们就可以引出一种新的算法：动态规划。</p>
<h3 id="11-什么是动态规划">1.1: 什么是动态规划</h3>
<p>动态规划（简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>说人话就是：当我们遇到一个很难直接解决的的大问题时，把它分解成一个个可以直接解决的小问题，再通过这些小问题的答案，从而求出大问题的解。</p>
<p>下面举一个例子：</p>
<blockquote>
<p>有一天，小K问小E :“你可以求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>114514</mn><mo>+</mo><mn>114514</mn></mrow><annotation encoding="application/x-tex">114514+114514</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span></span></span></span> 的值吗?”</p>
</blockquote>
<blockquote>
<p>小E想了一会说：“等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>229028</mn></mrow><annotation encoding="application/x-tex">229028</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">9</span><span class="mord">0</span><span class="mord">2</span><span class="mord">8</span></span></span></span> 。”</p>
</blockquote>
<blockquote>
<p>小K又问小E:“那你可以求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>114514</mn><mo>+</mo><mn>114514</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">114514+114514+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的值吗？”</p>
</blockquote>
<blockquote>
<p>小E几乎马上就回答：“等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>229029</mn></mrow><annotation encoding="application/x-tex">229029</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">9</span><span class="mord">0</span><span class="mord">2</span><span class="mord">9</span></span></span></span> 。”</p>
</blockquote>
<blockquote>
<p>小K很奇怪地问：“这次为什么你这么快就回答了问题呢？”</p>
</blockquote>
<blockquote>
<p>小E说：“因为我已经知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>114514</mn><mo>+</mo><mn>114514</mn></mrow><annotation encoding="application/x-tex">114514+114514</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span></span></span></span> 的值了，我只需要在原基础上加上一就可以了”</p>
</blockquote>
<p>小E解决小K第二个问题的过程其实就可以看成动态规划的过程。</p>
<p>那么我们来分析一下小 E 动态规划的过程。</p>
<p>首先，她把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>114514</mn><mo>+</mo><mn>114514</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">114514+114514+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这个大问题拆分为了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>114514</mn><mo>+</mo><mn>114514</mn></mrow><annotation encoding="application/x-tex">114514+114514</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span> 这两个子问题。</p>
<p>接着，她发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>114514</mn><mo>+</mo><mn>114514</mn></mrow><annotation encoding="application/x-tex">114514+114514</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span></span></span></span> 的答案已经知道了，所以把这个子问题的答案和另一个子问题的答案结合，就得到了：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>114514</mn><mo>+</mo><mn>114514</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">114514+114514+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mn>229028</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">=229028+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">9</span><span class="mord">0</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mn>229029</mn></mrow><annotation encoding="application/x-tex">=229029</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">9</span><span class="mord">0</span><span class="mord">2</span><span class="mord">9</span></span></span></span></p>
<h3 id="12-动态规划的元素">1.2: 动态规划的元素</h3>
<ol>
<li>
<p>最优化原理（最优子结构性质）:最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</p>
</li>
<li>
<p>无后效性：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p>
</li>
<li>
<p><strong>状态转移方程</strong>：这是动态规划的核心，表示是动态规划中本阶段的状态与上一阶段状态和上一阶段决策的关系。动态规划问题的难点就是如何推出状态转移方程。</p>
</li>
</ol>
<p>以上就是动态规划的基本定义，下面我们来看看如何实现。</p>
<h2 id="第二节动态规划算法的实现">第二节：动态规划算法的实现</h2>
<h3 id="20-例题引出1">2.0: 例题引出(1)</h3>
<blockquote>
<p><strong><a href="https://www.luogu.com.cn/problem/P1002"> (NOIP2002 普及组)  过河卒 </a></strong><br>
棋盘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 点有一个过河卒，需要走到目标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 点。卒行走的规则：可以向下、或者向右。同时在棋盘上  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。棋盘用坐标表示，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，同样马的位置坐标是需要给出的。</p>
</blockquote>
<blockquote>
<p>现在要求你计算出卒从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 点能够到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p>
</blockquote>
<h3 id="21-例题解决1">2.1: 例题解决(1)</h3>
<p>看到这道题可能同学们第一反应是搜索，但是我们不要急着下手，在实现之前，我们先分析一下算法的时间复杂度。</p>
<p>如果暴力判断的话，每个格子都要分别向右和向下递归，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mrow><mi>n</mi><mi>m</mi></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^{nm})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>由此可见，暴力判断时间复杂度是指数级的，如数据稍微大一点，就会 <code>TLE</code> ,所以我们呢可以考虑一下动态规划的做法。</p>
<p>看题，我们发现，如果从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 开始走，可能会面临数组越界的问题，所以我们不妨把每一个坐标都加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>我们使用动态规划解决问题，第一步是确定状态，在这道题中，我们定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 为从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 走到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 格的 <strong>路径条数</strong>。（本来应该是从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 开始走的，但是我们把所有坐标加了一）</p>
<p>第二步，就是去推状态转移方程了。</p>
<p>1 ：我们明确大问题：在马的拦截下，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n+1,m+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的路径条数。</p>
<p>2 ：我们把大问题拆分为更小的子问题：我们把从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的路径条数，拆分为从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i-1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的路径条数和从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的路径条数，这么拆下去，直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>3 ：寻找状态之间的关系：通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>  可知，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的路径条数，就是从原点走到这个格子上面的格子的路径条数加上从原点走到这个格子左边格子的路径条数之和。</p>
<p>形式化地来讲，就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>那么我们的状态转移方程其实就推出来了。</p>
<p>但是题目中路径是不可以经过马的控制点的，那么怎么办呢？</p>
<p>其实也很简单，如果格子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 是马的控制点（包括马本身在的格子），那么我们把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 标记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就可以了。</p>
<p>接下来就是代码实现了，我会把我的代码放在这里，但是请不要直接 <code>Ctrl+C</code>!</p>
<p>注意最终答案可能会很大，记得使用 <code>long long</code>。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define MAX(a,b) (a)&gt;(b)?(a):(b)
typedef long long inti;
using namespace std;
inline inti read()
{
    inti x=0,f=1;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9')f=-1,ch=getchar();
    while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}//快读
inti ans,dp[25][25];
bool s[25][25];
inti x,n=read(),y,m=read();
int main()
{
    x=read(),y=read();
    inti k[8]={x-2,x-1,x+1,x+2,x+2,x+1,x-1,x-2},kk[8]={y+1,y+2,y+2,y+1,y-1,y-2,y-2,y-1};
    dp[1][0]=1;
    s[x+1][y+1]=1;
    for(int i=0;i&lt;8;i++) s[k[i]+1][kk[i]+1]=1;
    for(int i=1;i&lt;=n+1;i++){
        for(int j=1;j&lt;=m+1;j++){
            if(s[i][j]) continue;
            dp[i][j]=dp[i-1][j]+dp[i][j-1];
        }
    }
	cout&lt;&lt;dp[n+1][m+1]&lt;&lt;endl;
	return 0;
}

</code></pre>
<p>如有错误，欢迎指正。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://elaina.mip001.top/post/hello-gridea/</id>
        <link href="https://elaina.mip001.top/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="https://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>